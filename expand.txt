pub mod libs {
    pub mod nodes {
        use config::NumberNodeInfo;
        use expr::ExprNodeInfo;
        use layer::{
            MelLayerNodeInfo, STFTLayerNodeInfo, SpectrogramDensityLayerNodeInfo,
        };
        use ndarray::{Array1, Array2};
        use raw_input::{FileInputNodeInfo, MicrophoneInputNodeInfo};
        use viewer::DataPlotterNodeInfo;
        pub mod config {
            use egui_editable_num::EditableOnText;
            use super::{NodeInfo, NodeInfoTypes};
            pub enum ConfigNodes {
                NumberNode(NumberNode),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ConfigNodes {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        ConfigNodes::NumberNode(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "NumberNode",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ConfigNodes {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            ConfigNodes::NumberNode(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "ConfigNodes",
                                    0u32,
                                    "NumberNode",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ConfigNodes {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 1",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "NumberNode" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"NumberNode" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ConfigNodes>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ConfigNodes;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum ConfigNodes",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                NumberNode,
                                            >(__variant),
                                            ConfigNodes::NumberNode,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &["NumberNode"];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "ConfigNodes",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ConfigNodes>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            impl ConfigNodes {
                pub fn name(&self) -> &str {
                    match self {
                        Self::NumberNode(_) => "NumberNode",
                    }
                }
                pub fn inputs(&self) -> usize {
                    match self {
                        Self::NumberNode(_) => NumberNodeInfo.inputs(),
                    }
                }
                pub fn outputs(&self) -> usize {
                    match self {
                        Self::NumberNode(_) => NumberNodeInfo.outputs(),
                    }
                }
            }
            pub struct NumberNode {
                pub name: String,
                pub number: EditableOnText<f64>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for NumberNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "NumberNode",
                        "name",
                        &self.name,
                        "number",
                        &&self.number,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for NumberNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "NumberNode",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "number",
                            &self.number,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for NumberNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "number" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"number" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<NumberNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = NumberNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct NumberNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct NumberNode with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    EditableOnText<f64>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct NumberNode with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(NumberNode {
                                    name: __field0,
                                    number: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    EditableOnText<f64>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("number"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    EditableOnText<f64>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("number")?
                                    }
                                };
                                _serde::__private::Ok(NumberNode {
                                    name: __field0,
                                    number: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["name", "number"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "NumberNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<NumberNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            pub struct NumberNodeInfo;
            impl NodeInfo for NumberNodeInfo {
                fn name(&self) -> &str {
                    "NumberNode"
                }
                fn inputs(&self) -> usize {
                    0
                }
                fn outputs(&self) -> usize {
                    1
                }
                fn input_types(&self) -> Vec<NodeInfoTypes> {
                    ::alloc::vec::Vec::new()
                }
                fn output_types(&self) -> Vec<NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([NodeInfoTypes::Number]),
                    )
                }
                fn flow_node(&self) -> super::editor::FlowNodes {
                    super::editor::FlowNodes::ConfigNodes(
                        ConfigNodes::NumberNode(Default::default()),
                    )
                }
            }
            impl Default for NumberNode {
                fn default() -> Self {
                    Self {
                        name: "NumberNode".to_string(),
                        number: EditableOnText::new(1024.),
                    }
                }
            }
            impl NumberNode {
                pub const fn inputs() -> usize {
                    0
                }
                pub const fn outputs() -> usize {
                    1
                }
                pub fn to_info(&self) -> NumberNodeInfo {
                    NumberNodeInfo
                }
            }
        }
        pub mod editor {
            use super::config::{ConfigNodes, NumberNode};
            use super::expr::ExprNodes;
            use super::layer::{LayerNodes, STFTLayerNode};
            use super::pin_info::CustomPinInfo;
            use super::raw_input::{FileInputNode, MicrophoneInputNode, RawInputNodes};
            use super::viewer::DataPlotterNode;
            use super::{NodeInfo, SerdeClone};
            use egui::Ui;
            use egui_snarl::{
                ui::{AnyPins, PinInfo, SnarlViewer},
                InPin, NodeId, OutPin, Snarl,
            };
            pub enum FlowNodes {
                LayerNodes(LayerNodes),
                ConfigNodes(ConfigNodes),
                DataPlotterNode(DataPlotterNode),
                RawInputNodes(RawInputNodes),
                ExprNode(ExprNodes),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for FlowNodes {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        FlowNodes::LayerNodes(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LayerNodes",
                                &__self_0,
                            )
                        }
                        FlowNodes::ConfigNodes(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "ConfigNodes",
                                &__self_0,
                            )
                        }
                        FlowNodes::DataPlotterNode(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "DataPlotterNode",
                                &__self_0,
                            )
                        }
                        FlowNodes::RawInputNodes(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "RawInputNodes",
                                &__self_0,
                            )
                        }
                        FlowNodes::ExprNode(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "ExprNode",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for FlowNodes {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            FlowNodes::LayerNodes(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FlowNodes",
                                    0u32,
                                    "LayerNodes",
                                    __field0,
                                )
                            }
                            FlowNodes::ConfigNodes(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FlowNodes",
                                    1u32,
                                    "ConfigNodes",
                                    __field0,
                                )
                            }
                            FlowNodes::DataPlotterNode(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FlowNodes",
                                    2u32,
                                    "DataPlotterNode",
                                    __field0,
                                )
                            }
                            FlowNodes::RawInputNodes(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FlowNodes",
                                    3u32,
                                    "RawInputNodes",
                                    __field0,
                                )
                            }
                            FlowNodes::ExprNode(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FlowNodes",
                                    4u32,
                                    "ExprNode",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for FlowNodes {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 5",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "LayerNodes" => _serde::__private::Ok(__Field::__field0),
                                    "ConfigNodes" => _serde::__private::Ok(__Field::__field1),
                                    "DataPlotterNode" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    "RawInputNodes" => _serde::__private::Ok(__Field::__field3),
                                    "ExprNode" => _serde::__private::Ok(__Field::__field4),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"LayerNodes" => _serde::__private::Ok(__Field::__field0),
                                    b"ConfigNodes" => _serde::__private::Ok(__Field::__field1),
                                    b"DataPlotterNode" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"RawInputNodes" => _serde::__private::Ok(__Field::__field3),
                                    b"ExprNode" => _serde::__private::Ok(__Field::__field4),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<FlowNodes>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = FlowNodes;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum FlowNodes",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                LayerNodes,
                                            >(__variant),
                                            FlowNodes::LayerNodes,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                ConfigNodes,
                                            >(__variant),
                                            FlowNodes::ConfigNodes,
                                        )
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                DataPlotterNode,
                                            >(__variant),
                                            FlowNodes::DataPlotterNode,
                                        )
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                RawInputNodes,
                                            >(__variant),
                                            FlowNodes::RawInputNodes,
                                        )
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                ExprNodes,
                                            >(__variant),
                                            FlowNodes::ExprNode,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "LayerNodes",
                            "ConfigNodes",
                            "DataPlotterNode",
                            "RawInputNodes",
                            "ExprNode",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "FlowNodes",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<FlowNodes>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            impl FlowNodes {
                pub fn to_as_info(&self) -> Box<dyn NodeInfo> {
                    match self {
                        FlowNodes::LayerNodes(node) => {
                            match node {
                                LayerNodes::STFTLayer(node) => Box::new(node.to_info()),
                                LayerNodes::MelLayer(node) => Box::new(node.to_info()),
                                LayerNodes::SpectrogramDensityLayer(node) => {
                                    Box::new(node.to_info())
                                }
                            }
                        }
                        FlowNodes::ConfigNodes(node) => {
                            match node {
                                ConfigNodes::NumberNode(node) => Box::new(node.to_info()),
                            }
                        }
                        FlowNodes::RawInputNodes(node) => {
                            match node {
                                RawInputNodes::MicrophoneInputNode(node) => {
                                    Box::new(node.to_info())
                                }
                                RawInputNodes::FileInputNode(node) => {
                                    Box::new(node.to_info())
                                }
                            }
                        }
                        FlowNodes::DataPlotterNode(node) => Box::new(node.to_info()),
                    }
                }
            }
            pub struct FlowNodesViewer;
            impl FlowNodesViewer {
                fn show_input(
                    &mut self,
                    pin: &egui_snarl::InPin,
                    ui: &mut egui::Ui,
                    scale: f32,
                    snarl: &egui_snarl::Snarl<FlowNodes>,
                ) -> Box<dyn Fn(&mut Snarl<FlowNodes>, &mut egui::Ui) -> MyPinInfo> {
                    let pin_id = pin.id;
                    match &snarl[pin.id.node] {
                        FlowNodes::LayerNodes(layer_nodes) => {
                            match layer_nodes {
                                LayerNodes::STFTLayer(_) => {
                                    match pin.id.input {
                                        0 => {
                                            if let Some(out_pin) = pin.remotes.get(0) {
                                                if let FlowNodes::ConfigNodes(
                                                    ConfigNodes::NumberNode(NumberNode { number, .. }),
                                                ) = &snarl[out_pin.node]
                                                {
                                                    ui.label(
                                                        ::alloc::__export::must_use({
                                                            let res = ::alloc::fmt::format(
                                                                format_args!("fft_size: {0}", number),
                                                            );
                                                            res
                                                        }),
                                                    );
                                                    let fft_size = number.get();
                                                    return Box::new(move |
                                                        snarl: &mut Snarl<FlowNodes>,
                                                        _: &mut egui::Ui|
                                                    {
                                                        if let FlowNodes::LayerNodes(LayerNodes::STFTLayer(node)) = &mut snarl[pin_id
                                                            .node]
                                                        {
                                                            if node.fft_size.set(fft_size as usize) {
                                                                node.update();
                                                            }
                                                        }
                                                        CustomPinInfo::lock()
                                                    });
                                                }
                                            }
                                            return Box::new(move |
                                                snarl: &mut Snarl<FlowNodes>,
                                                ui: &mut egui::Ui|
                                            {
                                                if let FlowNodes::LayerNodes(LayerNodes::STFTLayer(node)) = &mut snarl[pin_id
                                                    .node]
                                                {
                                                    ui.label("fft_size");
                                                    let response = egui::TextEdit::singleline(
                                                            &mut node.fft_size,
                                                        )
                                                        .clip_text(false)
                                                        .desired_width(0.0)
                                                        .margin(ui.spacing().item_spacing)
                                                        .show(ui)
                                                        .response;
                                                    if response.lost_focus() {
                                                        node.fft_size.fmt();
                                                        node.update();
                                                    } else if response.changed() {
                                                        if node.fft_size.try_update() {
                                                            node.update();
                                                        }
                                                    }
                                                }
                                                CustomPinInfo::setting(8)
                                            });
                                        }
                                        1 => {
                                            if let Some(out_pin) = pin.remotes.get(0) {
                                                if let FlowNodes::ConfigNodes(
                                                    ConfigNodes::NumberNode(NumberNode { number, .. }),
                                                ) = &snarl[out_pin.node]
                                                {
                                                    ui.label(
                                                        ::alloc::__export::must_use({
                                                            let res = ::alloc::fmt::format(
                                                                format_args!("hop_size: {0}", number),
                                                            );
                                                            res
                                                        }),
                                                    );
                                                    let hop_size = number.get();
                                                    return Box::new(move |
                                                        snarl: &mut Snarl<FlowNodes>,
                                                        _: &mut egui::Ui|
                                                    {
                                                        if let FlowNodes::LayerNodes(LayerNodes::STFTLayer(node)) = &mut snarl[pin_id
                                                            .node]
                                                        {
                                                            if node.hop_size.set(hop_size as usize) {
                                                                node.update();
                                                            }
                                                        }
                                                        CustomPinInfo::lock()
                                                    });
                                                }
                                            }
                                            return Box::new(move |
                                                snarl: &mut Snarl<FlowNodes>,
                                                ui: &mut egui::Ui|
                                            {
                                                if let FlowNodes::LayerNodes(LayerNodes::STFTLayer(node)) = &mut snarl[pin_id
                                                    .node]
                                                {
                                                    ui.label("hop_size");
                                                    let response = egui::TextEdit::singleline(
                                                            &mut node.hop_size,
                                                        )
                                                        .clip_text(false)
                                                        .desired_width(0.0)
                                                        .margin(ui.spacing().item_spacing)
                                                        .show(ui)
                                                        .response;
                                                    if response.lost_focus() {
                                                        node.hop_size.fmt();
                                                        node.update();
                                                    } else if response.changed() {
                                                        if node.hop_size.try_update() {
                                                            node.update();
                                                        }
                                                    }
                                                }
                                                CustomPinInfo::setting(8)
                                            });
                                        }
                                        2 => {
                                            ui.label("raw stream");
                                            if let Some(out_pin) = pin.remotes.get(0) {
                                                if let FlowNodes::RawInputNodes(node) = &snarl[out_pin.node]
                                                {
                                                    if let Some(data) = node.get() {
                                                        return Box::new(move |snarl: &mut Snarl<FlowNodes>, _| {
                                                            if let FlowNodes::LayerNodes(LayerNodes::STFTLayer(node)) = &mut snarl[pin_id
                                                                .node]
                                                            {
                                                                if let Err(err) = node.calc(&data) {
                                                                    {
                                                                        let lvl = ::log::Level::Error;
                                                                        if lvl <= ::log::STATIC_MAX_LEVEL
                                                                            && lvl <= ::log::max_level()
                                                                        {
                                                                            ::log::__private_api::log(
                                                                                format_args!("STFTLayerNode: {0}", err),
                                                                                lvl,
                                                                                &(
                                                                                    "audio_analyzer_app::libs::nodes::editor",
                                                                                    "audio_analyzer_app::libs::nodes::editor",
                                                                                    ::log::__private_api::loc(),
                                                                                ),
                                                                                (),
                                                                            );
                                                                        }
                                                                    };
                                                                }
                                                            }
                                                            CustomPinInfo::lock()
                                                        });
                                                    }
                                                }
                                            }
                                            return Box::new(|_, _| {
                                                PinInfo::circle()
                                                    .with_fill(egui::Color32::from_rgb(255, 0, 0))
                                            });
                                        }
                                        _ => {
                                            ::core::panicking::panic(
                                                "internal error: entered unreachable code",
                                            )
                                        }
                                    }
                                }
                                LayerNodes::MelLayer(_) => {
                                    ::core::panicking::panic("not yet implemented")
                                }
                                LayerNodes::SpectrogramDensityLayer(_) => {
                                    ::core::panicking::panic("not yet implemented")
                                }
                            }
                        }
                        FlowNodes::ConfigNodes(_) => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                        FlowNodes::RawInputNodes(raw_input_nodes) => {
                            match raw_input_nodes {
                                RawInputNodes::MicrophoneInputNode(_) => {
                                    ::core::panicking::panic(
                                        "internal error: entered unreachable code",
                                    )
                                }
                                RawInputNodes::FileInputNode(_) => {
                                    ::core::panicking::panic("not yet implemented")
                                }
                            }
                        }
                        FlowNodes::DataPlotterNode(_) => {
                            if let Some(out_pin) = pin.remotes.get(0) {
                                let remote = &snarl[out_pin.node];
                                let data = remote.to_node_info_types_with_data();
                                return Box::new(move |
                                    snarl: &mut Snarl<FlowNodes>,
                                    ui: &mut egui::Ui|
                                {
                                    if let FlowNodes::DataPlotterNode(node) = &mut snarl[pin_id
                                        .node]
                                    {
                                        if let Some(data) = &data {
                                            node.set_hold_data(data.clone());
                                            node.show(ui, true, scale);
                                            return PinInfo::circle()
                                                .with_fill(egui::Color32::from_rgb(0, 255, 0));
                                        } else {
                                            node.show(ui, false, scale);
                                        }
                                    }
                                    PinInfo::circle()
                                        .with_fill(egui::Color32::from_rgb(0, 0, 255))
                                });
                            }
                            return Box::new(|_, _| {
                                PinInfo::circle()
                                    .with_fill(egui::Color32::from_rgb(0, 0, 255))
                            });
                        }
                    };
                }
            }
            impl SnarlViewer<FlowNodes> for FlowNodesViewer {
                #[inline]
                fn connect(
                    &mut self,
                    from: &egui_snarl::OutPin,
                    to: &egui_snarl::InPin,
                    snarl: &mut Snarl<FlowNodes>,
                ) {
                    let in_type = snarl[to.id.node]
                        .to_as_info()
                        .input_types()[to.id.input];
                    let out_type = snarl[from.id.node]
                        .to_as_info()
                        .output_types()[from.id.output];
                    if in_type != out_type {
                        return;
                    }
                    for &remote in &to.remotes {
                        snarl.disconnect(remote, to.id);
                    }
                    snarl.connect(from.id, to.id);
                }
                fn title(&mut self, node: &FlowNodes) -> String {
                    node.to_as_info().name().to_string()
                }
                fn inputs(&mut self, node: &FlowNodes) -> usize {
                    node.to_as_info().inputs()
                }
                fn outputs(&mut self, node: &FlowNodes) -> usize {
                    node.to_as_info().outputs()
                }
                fn show_input(
                    &mut self,
                    pin: &egui_snarl::InPin,
                    ui: &mut egui::Ui,
                    scale: f32,
                    snarl: &mut egui_snarl::Snarl<FlowNodes>,
                ) -> egui_snarl::ui::PinInfo {
                    self.show_input(pin, ui, scale, snarl)(snarl, ui)
                }
                fn show_output(
                    &mut self,
                    pin: &egui_snarl::OutPin,
                    ui: &mut egui::Ui,
                    _scale: f32,
                    snarl: &mut egui_snarl::Snarl<FlowNodes>,
                ) -> egui_snarl::ui::PinInfo {
                    match &mut snarl[pin.id.node] {
                        FlowNodes::LayerNodes(layer_nodes) => {
                            match layer_nodes {
                                LayerNodes::STFTLayer(_) => {
                                    ui.label("output STFTLayer");
                                    PinInfo::circle()
                                        .with_fill(egui::Color32::from_rgb(0, 0, 0))
                                }
                                LayerNodes::MelLayer(_) => {
                                    ::core::panicking::panic("not yet implemented")
                                }
                                LayerNodes::SpectrogramDensityLayer(_) => {
                                    ::core::panicking::panic("not yet implemented")
                                }
                            }
                        }
                        FlowNodes::ConfigNodes(config_nodes) => {
                            match config_nodes {
                                ConfigNodes::NumberNode(node) => {
                                    ui.end_row();
                                    if egui::TextEdit::singleline(&mut node.number)
                                        .clip_text(false)
                                        .desired_width(0.0)
                                        .margin(ui.spacing().item_spacing)
                                        .show(ui)
                                        .response
                                        .lost_focus()
                                    {
                                        node.number.fmt();
                                    }
                                    egui::TextEdit::singleline(&mut node.name)
                                        .clip_text(false)
                                        .desired_width(0.0)
                                        .margin(ui.spacing().item_spacing)
                                        .show(ui);
                                    CustomPinInfo::setting(8)
                                }
                            }
                        }
                        FlowNodes::RawInputNodes(raw_input_nodes) => {
                            match raw_input_nodes {
                                RawInputNodes::MicrophoneInputNode(node) => {
                                    node.update();
                                    ui.label("raw stream");
                                    PinInfo::circle()
                                        .with_fill(egui::Color32::from_rgb(255, 0, 0))
                                }
                                RawInputNodes::FileInputNode(_) => {
                                    ::core::panicking::panic("not yet implemented")
                                }
                            }
                        }
                        FlowNodes::DataPlotterNode(_) => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
                fn has_graph_menu(
                    &mut self,
                    _pos: egui::Pos2,
                    _snarl: &mut Snarl<FlowNodes>,
                ) -> bool {
                    true
                }
                fn show_graph_menu(
                    &mut self,
                    pos: egui::Pos2,
                    ui: &mut Ui,
                    _scale: f32,
                    snarl: &mut Snarl<FlowNodes>,
                ) {
                    ui.label("Add node");
                    if ui.button("STFTLayer").clicked() {
                        snarl
                            .insert_node(
                                pos,
                                FlowNodes::LayerNodes(
                                    LayerNodes::STFTLayer(STFTLayerNode::default()),
                                ),
                            );
                        ui.close_menu();
                    }
                    ui.menu_button(
                        "config",
                        |ui| {
                            if ui.button("number_node").clicked() {
                                snarl
                                    .insert_node(
                                        pos,
                                        FlowNodes::ConfigNodes(
                                            ConfigNodes::NumberNode(NumberNode::default()),
                                        ),
                                    );
                                ui.close_menu();
                            }
                        },
                    );
                    ui.menu_button(
                        "raw_input",
                        |ui| {
                            if ui.button("MicrophoneInputNode").clicked() {
                                snarl
                                    .insert_node(
                                        pos,
                                        FlowNodes::RawInputNodes(
                                            RawInputNodes::MicrophoneInputNode(
                                                MicrophoneInputNode::default(),
                                            ),
                                        ),
                                    );
                                ui.close_menu();
                            }
                            if ui.button("FileInputNode").clicked() {
                                snarl
                                    .insert_node(
                                        pos,
                                        FlowNodes::RawInputNodes(
                                            RawInputNodes::FileInputNode(FileInputNode::default()),
                                        ),
                                    );
                                ui.close_menu();
                            }
                        },
                    );
                    ui.menu_button(
                        "viewer",
                        |ui| {
                            if ui.button("DataPlotterNode").clicked() {
                                snarl
                                    .insert_node(
                                        pos,
                                        FlowNodes::DataPlotterNode(DataPlotterNode::default()),
                                    );
                                ui.close_menu();
                            }
                        },
                    );
                }
                fn has_node_menu(&mut self, _node: &FlowNodes) -> bool {
                    true
                }
                fn show_node_menu(
                    &mut self,
                    node: NodeId,
                    _inputs: &[InPin],
                    _outputs: &[OutPin],
                    ui: &mut Ui,
                    _scale: f32,
                    snarl: &mut Snarl<FlowNodes>,
                ) {
                    ui.label("Node menu");
                    if ui.button("Remove").clicked() {
                        snarl.remove_node(node);
                        ui.close_menu();
                    }
                    if ui.button("Duplicate").clicked() {
                        let duplicate_node: FlowNodes = snarl[node].serde_clone();
                        let mut now_pos = snarl.get_node_info(node).unwrap().pos;
                        now_pos.x += 20.0;
                        now_pos.y += 20.0;
                        snarl.insert_node(now_pos, duplicate_node);
                        ui.close_menu();
                    }
                }
                fn has_dropped_wire_menu(
                    &mut self,
                    _src_pins: AnyPins,
                    _snarl: &mut Snarl<FlowNodes>,
                ) -> bool {
                    true
                }
                fn show_dropped_wire_menu(
                    &mut self,
                    pos: egui::Pos2,
                    ui: &mut Ui,
                    _scale: f32,
                    src_pins: AnyPins,
                    snarl: &mut Snarl<FlowNodes>,
                ) {
                    ui.style_mut().wrap_mode = Some(egui::TextWrapMode::Extend);
                    ui.label("Add node");
                    match src_pins {
                        AnyPins::In(pin) => {
                            if !(pin.len() == 1) {
                                ::core::panicking::panic("assertion failed: pin.len() == 1")
                            }
                            let pin = &pin[0];
                            let mut view_connect_in_node = |
                                node: &dyn NodeInfo,
                                snarl: &mut Snarl<FlowNodes>|
                            {
                                let input_id = pin.input;
                                let in_type = node.input_types()[input_id];
                                let all = super::NodeInfos::all();
                                for node in all {
                                    let out_type = node.output_types();
                                    if in_type.contains_in(&out_type) {
                                        if ui.button(node.name()).clicked() {
                                            let mut pos = pos;
                                            pos.x -= 100.0;
                                            pos.y += 20.0;
                                            let node = node.flow_node();
                                            let new_node = snarl.insert_node(pos, node);
                                            let dst_pin = egui_snarl::OutPinId {
                                                node: new_node,
                                                output: in_type.positions_in(&out_type)[0],
                                            };
                                            snarl.connect(dst_pin, pin.clone());
                                            ui.close_menu();
                                        }
                                    }
                                }
                            };
                            let node = &snarl[pin.node];
                            let as_info = node.to_as_info();
                            view_connect_in_node(as_info.as_ref(), snarl);
                        }
                        AnyPins::Out(pin) => {
                            if !(pin.len() == 1) {
                                ::core::panicking::panic("assertion failed: pin.len() == 1")
                            }
                            let pin = &pin[0];
                            let mut view_connect_out_node = |
                                node: &dyn NodeInfo,
                                snarl: &mut Snarl<FlowNodes>|
                            {
                                let output_id = pin.output;
                                let out_type = node.output_types()[output_id];
                                let all = super::NodeInfos::all();
                                for node in all {
                                    let in_type = node.input_types();
                                    if out_type.contains_out(&in_type) {
                                        if ui.button(node.name()).clicked() {
                                            let mut pos = pos;
                                            pos.x += 100.0;
                                            pos.y += 20.0;
                                            let node = node.flow_node();
                                            let new_node = snarl.insert_node(pos, node);
                                            let src_pin = egui_snarl::InPinId {
                                                node: new_node,
                                                input: out_type.positions_out(&in_type)[0],
                                            };
                                            snarl.connect(pin.clone(), src_pin);
                                            ui.close_menu();
                                        }
                                    }
                                }
                            };
                            let node = &snarl[pin.node];
                            let as_info = node.to_as_info();
                            view_connect_out_node(as_info.as_ref(), snarl);
                        }
                    }
                }
            }
        }
        pub mod expr {
            use std::{cell::RefCell, collections::BTreeMap, rc::Rc};
            use egui::output;
            use egui_editable_num::EditableOnText;
            use fasteval3::{Compiler, EmptyNamespace, Instruction};
            use std::fmt::{self, Debug};
            use super::{NodeInfo, NodeInfoTypes};
            pub struct ExprNodes {
                pub inputs_num: EditableOnText<usize>,
                pub input_var_names: Vec<String>,
                pub expr_str: String,
                pub outputs_num: EditableOnText<usize>,
                pub calculated: Option<Vec<f64>>,
                #[serde(skip)]
                cb: RefCell<Box<dyn Fn(&str, Vec<f64>) -> Option<f64>>>,
                #[serde(skip)]
                accessor: Rc<RefCell<BTreeMap<String, f64>>>,
                #[serde(skip)]
                ret: Rc<RefCell<Vec<f64>>>,
                #[serde(skip)]
                pub slab: fasteval3::Slab,
                #[serde(skip)]
                pub compiled: Option<Instruction>,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ExprNodes {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ExprNodes",
                            false as usize + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "inputs_num",
                            &self.inputs_num,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "input_var_names",
                            &self.input_var_names,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "expr_str",
                            &self.expr_str,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "outputs_num",
                            &self.outputs_num,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "calculated",
                            &self.calculated,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl Debug for ExprNodes {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.debug_struct("ExprNodes")
                        .field("inputs_num", &self.inputs_num)
                        .field("input_var_names", &self.input_var_names)
                        .field("expr_str", &self.expr_str)
                        .finish()
                }
            }
            pub struct ExprNodeInfo {
                pub inputs_num: usize,
                pub input_types: Vec<NodeInfoTypes>,
                pub outputs_num: usize,
            }
            impl Default for ExprNodeInfo {
                fn default() -> Self {
                    Self {
                        inputs_num: 0,
                        input_types: ::alloc::vec::Vec::new(),
                        outputs_num: 1,
                    }
                }
            }
            impl NodeInfo for ExprNodeInfo {
                fn name(&self) -> &str {
                    "ExprNodes"
                }
                fn inputs(&self) -> usize {
                    self.inputs_num
                }
                fn outputs(&self) -> usize {
                    self.outputs_num
                }
                fn input_types(&self) -> Vec<NodeInfoTypes> {
                    self.input_types.clone()
                }
                fn output_types(&self) -> Vec<NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([NodeInfoTypes::Number]),
                    )
                }
                fn flow_node(&self) -> super::editor::FlowNodes {
                    super::editor::FlowNodes::ExprNode(Default::default())
                }
            }
            impl Default for ExprNodes {
                fn default() -> Self {
                    Self::new(0, ::alloc::vec::Vec::new(), "2 * 3".to_string(), 1)
                }
            }
            impl ExprNodes {
                pub fn new(
                    inputs_num: usize,
                    input_var_names: Vec<String>,
                    expr_str: String,
                    outputs_num: usize,
                ) -> Self {
                    let (cb, access_vars, ret_values) = Self::create_cb();
                    Self {
                        inputs_num: EditableOnText::new(inputs_num),
                        input_var_names,
                        expr_str,
                        outputs_num: EditableOnText::new(outputs_num),
                        calculated: None,
                        cb,
                        accessor: access_vars,
                        ret: ret_values,
                        slab: fasteval3::Slab::new(),
                    }
                }
                pub fn to_info(&self) -> ExprNodeInfo {
                    ExprNodeInfo {
                        inputs_num: self.inputs_num.get(),
                        input_types: ::alloc::vec::from_elem(
                            NodeInfoTypes::Number,
                            self.inputs_num.get(),
                        ),
                        outputs_num: self.outputs_num.get(),
                    }
                }
                pub fn create_cb() -> (
                    RefCell<Box<dyn Fn(&str, Vec<f64>) -> Option<f64>>>,
                    Rc<RefCell<BTreeMap<String, f64>>>,
                    Rc<RefCell<Vec<f64>>>,
                ) {
                    let access_vars: Rc<RefCell<BTreeMap<String, f64>>> = Rc::new(
                        RefCell::new(BTreeMap::new()),
                    );
                    let ret_values = Rc::new(RefCell::new(Vec::new()));
                    let ret_values_clone = ret_values.clone();
                    let access_vars_clone = access_vars.clone();
                    let cb = RefCell::new(
                        Box::new(move |name: &str, args: Vec<f64>| -> Option<f64> {
                            match name {
                                "tuple" => {
                                    let mut ret_values = ret_values_clone.borrow_mut();
                                    ret_values.clear();
                                    for arg in args {
                                        ret_values.push(arg);
                                    }
                                    return Some(0.0);
                                }
                                _ => {}
                            }
                            let access_vars = access_vars_clone.borrow();
                            if let Some(var) = access_vars.get(name) {
                                return Some(*var);
                            }
                            None
                        }),
                    );
                    (cb, access_vars, ret_values)
                }
                pub fn update(&mut self) {
                    let Self { expr_str, slab, .. } = self;
                    let parser = fasteval3::Parser::new();
                    if let Ok(parsed) = parser.parse(expr_str, &mut slab.ps) {
                        let compiled = parsed
                            .from(&slab.ps)
                            .compile(&slab.ps, &mut slab.cs, &mut EmptyNamespace);
                        self.compiled = Some(compiled);
                    }
                }
                pub fn eval(&self, inputs: Vec<f64>) -> Option<Vec<f64>> {
                    use fasteval3::Evaler;
                    let Self {
                        cb,
                        accessor,
                        ret,
                        compiled,
                        inputs_num,
                        input_var_names,
                        expr_str,
                        outputs_num,
                        calculated,
                        slab,
                    } = self;
                    if !(inputs.len() == inputs_num.get()) {
                        ::core::panicking::panic(
                            "assertion failed: inputs.len() == inputs_num.get()",
                        )
                    }
                    let mut access_vars = accessor.borrow_mut();
                    access_vars.clear();
                    for (name, value) in input_var_names.iter().zip(inputs.iter()) {
                        access_vars.insert(name.clone(), *value);
                    }
                    std::mem::drop(access_vars);
                    if let Some(compiled) = compiled {
                        let cb = cb.borrow();
                        let result = if let fasteval3::IConst(c) = compiled {
                            *c
                        } else {
                            #[cfg(not(feature = "unsafe-vars"))]
                            compiled.eval(slab, { &mut cb })?
                        };
                    }
                    None
                }
            }
        }
        pub mod layer {
            use std::any::TypeId;
            use audio_analyzer_core::mel_layer::{
                fft_layer::{FftConfig, ToSpectrogramLayer},
                spectral_density::{
                    ToPowerSpectralDensityLayer, ToPowerSpectralDensityLayerConfig,
                },
                to_mel_layer::ToMelSpectrogramLayer,
            };
            use egui_editable_num::EditableOnText;
            use mel_spec::config::MelConfig;
            use ndarray::{Array1, Array2};
            use num_complex::Complex;
            use serde::de;
            use crate::libs::nodes::NodeInfoTypes;
            use super::NodeInfo;
            pub enum LayerNodes {
                STFTLayer(STFTLayerNode),
                MelLayer(MelLayerNode),
                SpectrogramDensityLayer(SpectrogramDensityLayerNode),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for LayerNodes {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        LayerNodes::STFTLayer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "STFTLayer",
                                &__self_0,
                            )
                        }
                        LayerNodes::MelLayer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "MelLayer",
                                &__self_0,
                            )
                        }
                        LayerNodes::SpectrogramDensityLayer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "SpectrogramDensityLayer",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for LayerNodes {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            LayerNodes::STFTLayer(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "LayerNodes",
                                    0u32,
                                    "STFTLayer",
                                    __field0,
                                )
                            }
                            LayerNodes::MelLayer(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "LayerNodes",
                                    1u32,
                                    "MelLayer",
                                    __field0,
                                )
                            }
                            LayerNodes::SpectrogramDensityLayer(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "LayerNodes",
                                    2u32,
                                    "SpectrogramDensityLayer",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for LayerNodes {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "STFTLayer" => _serde::__private::Ok(__Field::__field0),
                                    "MelLayer" => _serde::__private::Ok(__Field::__field1),
                                    "SpectrogramDensityLayer" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"STFTLayer" => _serde::__private::Ok(__Field::__field0),
                                    b"MelLayer" => _serde::__private::Ok(__Field::__field1),
                                    b"SpectrogramDensityLayer" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<LayerNodes>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = LayerNodes;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum LayerNodes",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                STFTLayerNode,
                                            >(__variant),
                                            LayerNodes::STFTLayer,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                MelLayerNode,
                                            >(__variant),
                                            LayerNodes::MelLayer,
                                        )
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                SpectrogramDensityLayerNode,
                                            >(__variant),
                                            LayerNodes::SpectrogramDensityLayer,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "STFTLayer",
                            "MelLayer",
                            "SpectrogramDensityLayer",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "LayerNodes",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LayerNodes>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            impl LayerNodes {
                pub fn name(&self) -> &str {
                    match self {
                        LayerNodes::STFTLayer(_) => "STFTLayer",
                        LayerNodes::MelLayer(_) => "MelLayer",
                        LayerNodes::SpectrogramDensityLayer(_) => {
                            "SpectrogramDensityLayer"
                        }
                    }
                }
                pub fn update(&mut self) {
                    match self {
                        LayerNodes::STFTLayer(node) => node.update(),
                        LayerNodes::MelLayer(node) => node.update(),
                        LayerNodes::SpectrogramDensityLayer(node) => node.update(),
                    }
                }
                pub const fn inputs(&self) -> usize {
                    match self {
                        LayerNodes::STFTLayer(_) => STFTLayerNode::input(),
                        LayerNodes::MelLayer(_) => MelLayerNode::input(),
                        LayerNodes::SpectrogramDensityLayer(_) => {
                            SpectrogramDensityLayerNode::input()
                        }
                    }
                }
                pub const fn outputs(&self) -> usize {
                    1
                }
                pub fn input_type_id(&self) -> TypeId {
                    match self {
                        LayerNodes::STFTLayer(_) => {
                            TypeId::of::<<STFTLayerNode as InputAndOutputType>::Input>()
                        }
                        LayerNodes::MelLayer(_) => {
                            TypeId::of::<<MelLayerNode as InputAndOutputType>::Input>()
                        }
                        LayerNodes::SpectrogramDensityLayer(_) => {
                            TypeId::of::<
                                <SpectrogramDensityLayerNode as InputAndOutputType>::Input,
                            >()
                        }
                    }
                }
                pub fn output_type_id(&self) -> TypeId {
                    match self {
                        LayerNodes::STFTLayer(_) => {
                            TypeId::of::<<STFTLayerNode as InputAndOutputType>::Output>()
                        }
                        LayerNodes::MelLayer(_) => {
                            TypeId::of::<<MelLayerNode as InputAndOutputType>::Output>()
                        }
                        LayerNodes::SpectrogramDensityLayer(_) => {
                            TypeId::of::<
                                <SpectrogramDensityLayerNode as InputAndOutputType>::Output,
                            >()
                        }
                    }
                }
                pub fn validate_connections(&self, to: &LayerNodes) -> bool {
                    let input_type_id = self.output_type_id();
                    let output_type_id = to.input_type_id();
                    input_type_id == output_type_id
                }
            }
            pub trait InputAndOutputType {
                type Input: 'static;
                type Output: 'static;
            }
            pub struct STFTLayerNode {
                pub fft_size: EditableOnText<usize>,
                pub hop_size: EditableOnText<usize>,
                #[serde(skip)]
                layer: ToSpectrogramLayer,
                #[serde(skip)]
                result: Option<Array1<Complex<f64>>>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for STFTLayerNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "STFTLayerNode",
                        "fft_size",
                        &self.fft_size,
                        "hop_size",
                        &self.hop_size,
                        "layer",
                        &self.layer,
                        "result",
                        &&self.result,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for STFTLayerNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "STFTLayerNode",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "fft_size",
                            &self.fft_size,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "hop_size",
                            &self.hop_size,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            pub struct STFTLayerNodeInfo;
            impl NodeInfo for STFTLayerNodeInfo {
                fn name(&self) -> &str {
                    "STFTLayer"
                }
                fn inputs(&self) -> usize {
                    STFTLayerNode::input()
                }
                fn outputs(&self) -> usize {
                    1
                }
                fn input_types(&self) -> Vec<NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            NodeInfoTypes::Number,
                            NodeInfoTypes::Number,
                            NodeInfoTypes::VecF32,
                        ]),
                    )
                }
                fn output_types(&self) -> Vec<NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([NodeInfoTypes::Array1ComplexF64]),
                    )
                }
                fn flow_node(&self) -> super::editor::FlowNodes {
                    super::editor::FlowNodes::LayerNodes(
                        LayerNodes::STFTLayer(Default::default()),
                    )
                }
            }
            impl<'a> serde::Deserialize<'a> for STFTLayerNode {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: de::Deserializer<'a>,
                {
                    struct STFTLayerNodeHelper {
                        fft_size: EditableOnText<usize>,
                        hop_size: EditableOnText<usize>,
                    }
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications
                    )]
                    const _: () = {
                        #[allow(unused_extern_crates, clippy::useless_attribute)]
                        extern crate serde as _serde;
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for STFTLayerNodeHelper {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "fft_size" => _serde::__private::Ok(__Field::__field0),
                                            "hop_size" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"fft_size" => _serde::__private::Ok(__Field::__field0),
                                            b"hop_size" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<STFTLayerNodeHelper>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = STFTLayerNodeHelper;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct STFTLayerNodeHelper",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            EditableOnText<usize>,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct STFTLayerNodeHelper with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match _serde::de::SeqAccess::next_element::<
                                            EditableOnText<usize>,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct STFTLayerNodeHelper with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(STFTLayerNodeHelper {
                                            fft_size: __field0,
                                            hop_size: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            EditableOnText<usize>,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            EditableOnText<usize>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                            __Field,
                                        >(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "fft_size",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<
                                                            EditableOnText<usize>,
                                                        >(&mut __map)?,
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "hop_size",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<
                                                            EditableOnText<usize>,
                                                        >(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("fft_size")?
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("hop_size")?
                                            }
                                        };
                                        _serde::__private::Ok(STFTLayerNodeHelper {
                                            fft_size: __field0,
                                            hop_size: __field1,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &[
                                    "fft_size",
                                    "hop_size",
                                ];
                                _serde::Deserializer::deserialize_struct(
                                    __deserializer,
                                    "STFTLayerNodeHelper",
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<
                                            STFTLayerNodeHelper,
                                        >,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    let helper = STFTLayerNodeHelper::deserialize(deserializer)?;
                    Ok(STFTLayerNode::new(helper.fft_size.get(), helper.hop_size.get()))
                }
            }
            impl Default for STFTLayerNode {
                fn default() -> Self {
                    let config = FftConfig::default();
                    Self::new(config.fft_size, config.hop_size)
                }
            }
            impl InputAndOutputType for STFTLayerNode {
                type Input = Vec<f32>;
                type Output = Array1<Complex<f64>>;
            }
            impl STFTLayerNode {
                pub fn new(fft_size: usize, hop_size: usize) -> Self {
                    let layer = ToSpectrogramLayer::new(
                        FftConfig::new(fft_size, hop_size),
                    );
                    Self {
                        fft_size: EditableOnText::new(fft_size),
                        hop_size: EditableOnText::new(hop_size),
                        layer,
                        result: None,
                    }
                }
                pub fn calc(&mut self, data: &Vec<f32>) -> crate::Result<()> {
                    self.result = self.layer.through_inner(data)?.pop();
                    Ok(())
                }
                pub fn update(&mut self) {
                    self.layer = ToSpectrogramLayer::new(
                        FftConfig::new(self.fft_size.get(), self.hop_size.get()),
                    );
                }
                pub fn get_result(&self) -> Option<Array1<Complex<f64>>> {
                    self.result.clone()
                }
                pub const fn input() -> usize {
                    1 + 2
                }
                pub fn to_info(&self) -> STFTLayerNodeInfo {
                    STFTLayerNodeInfo
                }
            }
            pub struct MelLayerNode {
                pub fft_size: EditableOnText<usize>,
                pub hop_size: EditableOnText<usize>,
                pub n_mels: EditableOnText<usize>,
                pub sample_rate: EditableOnText<f64>,
                #[serde(skip)]
                layer: ToMelSpectrogramLayer,
                #[serde(skip)]
                result: Option<Array2<f64>>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MelLayerNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "fft_size",
                        "hop_size",
                        "n_mels",
                        "sample_rate",
                        "layer",
                        "result",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.fft_size,
                        &self.hop_size,
                        &self.n_mels,
                        &self.sample_rate,
                        &self.layer,
                        &&self.result,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "MelLayerNode",
                        names,
                        values,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for MelLayerNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "MelLayerNode",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "fft_size",
                            &self.fft_size,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "hop_size",
                            &self.hop_size,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "n_mels",
                            &self.n_mels,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "sample_rate",
                            &self.sample_rate,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            pub struct MelLayerNodeInfo;
            impl NodeInfo for MelLayerNodeInfo {
                fn name(&self) -> &str {
                    "MelLayer"
                }
                fn inputs(&self) -> usize {
                    MelLayerNode::input()
                }
                fn outputs(&self) -> usize {
                    1
                }
                fn input_types(&self) -> Vec<NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            NodeInfoTypes::Number,
                            NodeInfoTypes::Number,
                            NodeInfoTypes::Array1ComplexF64,
                        ]),
                    )
                }
                fn output_types(&self) -> Vec<NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([NodeInfoTypes::Array2F64]),
                    )
                }
                fn flow_node(&self) -> super::editor::FlowNodes {
                    super::editor::FlowNodes::LayerNodes(
                        LayerNodes::MelLayer(Default::default()),
                    )
                }
            }
            impl<'a> serde::Deserialize<'a> for MelLayerNode {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: de::Deserializer<'a>,
                {
                    struct MelLayerNodeHelper {
                        fft_size: EditableOnText<usize>,
                        hop_size: EditableOnText<usize>,
                        n_mels: EditableOnText<usize>,
                        sample_rate: EditableOnText<f64>,
                    }
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications
                    )]
                    const _: () = {
                        #[allow(unused_extern_crates, clippy::useless_attribute)]
                        extern crate serde as _serde;
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for MelLayerNodeHelper {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            3u64 => _serde::__private::Ok(__Field::__field3),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "fft_size" => _serde::__private::Ok(__Field::__field0),
                                            "hop_size" => _serde::__private::Ok(__Field::__field1),
                                            "n_mels" => _serde::__private::Ok(__Field::__field2),
                                            "sample_rate" => _serde::__private::Ok(__Field::__field3),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"fft_size" => _serde::__private::Ok(__Field::__field0),
                                            b"hop_size" => _serde::__private::Ok(__Field::__field1),
                                            b"n_mels" => _serde::__private::Ok(__Field::__field2),
                                            b"sample_rate" => _serde::__private::Ok(__Field::__field3),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<MelLayerNodeHelper>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = MelLayerNodeHelper;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct MelLayerNodeHelper",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            EditableOnText<usize>,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct MelLayerNodeHelper with 4 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match _serde::de::SeqAccess::next_element::<
                                            EditableOnText<usize>,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct MelLayerNodeHelper with 4 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match _serde::de::SeqAccess::next_element::<
                                            EditableOnText<usize>,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct MelLayerNodeHelper with 4 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field3 = match _serde::de::SeqAccess::next_element::<
                                            EditableOnText<f64>,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        3usize,
                                                        &"struct MelLayerNodeHelper with 4 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(MelLayerNodeHelper {
                                            fft_size: __field0,
                                            hop_size: __field1,
                                            n_mels: __field2,
                                            sample_rate: __field3,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            EditableOnText<usize>,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            EditableOnText<usize>,
                                        > = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<
                                            EditableOnText<usize>,
                                        > = _serde::__private::None;
                                        let mut __field3: _serde::__private::Option<
                                            EditableOnText<f64>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                            __Field,
                                        >(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "fft_size",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<
                                                            EditableOnText<usize>,
                                                        >(&mut __map)?,
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "hop_size",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<
                                                            EditableOnText<usize>,
                                                        >(&mut __map)?,
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("n_mels"),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<
                                                            EditableOnText<usize>,
                                                        >(&mut __map)?,
                                                    );
                                                }
                                                __Field::__field3 => {
                                                    if _serde::__private::Option::is_some(&__field3) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "sample_rate",
                                                            ),
                                                        );
                                                    }
                                                    __field3 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<
                                                            EditableOnText<f64>,
                                                        >(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("fft_size")?
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("hop_size")?
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("n_mels")?
                                            }
                                        };
                                        let __field3 = match __field3 {
                                            _serde::__private::Some(__field3) => __field3,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("sample_rate")?
                                            }
                                        };
                                        _serde::__private::Ok(MelLayerNodeHelper {
                                            fft_size: __field0,
                                            hop_size: __field1,
                                            n_mels: __field2,
                                            sample_rate: __field3,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &[
                                    "fft_size",
                                    "hop_size",
                                    "n_mels",
                                    "sample_rate",
                                ];
                                _serde::Deserializer::deserialize_struct(
                                    __deserializer,
                                    "MelLayerNodeHelper",
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<
                                            MelLayerNodeHelper,
                                        >,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    let helper = MelLayerNodeHelper::deserialize(deserializer)?;
                    Ok(
                        MelLayerNode::new(
                            helper.fft_size.get(),
                            helper.hop_size.get(),
                            helper.n_mels.get(),
                            helper.sample_rate.get(),
                        ),
                    )
                }
            }
            impl Default for MelLayerNode {
                fn default() -> Self {
                    Self::new(400, 160, 128, 44100.0)
                }
            }
            impl InputAndOutputType for MelLayerNode {
                type Input = Array1<Complex<f64>>;
                type Output = Array2<f64>;
            }
            impl MelLayerNode {
                pub fn new(
                    fft_size: usize,
                    hop_size: usize,
                    n_mels: usize,
                    sample_rate: f64,
                ) -> Self {
                    let layer = ToMelSpectrogramLayer::new(
                        MelConfig::new(fft_size, hop_size, n_mels, sample_rate),
                    );
                    Self {
                        fft_size: EditableOnText::new(fft_size),
                        hop_size: EditableOnText::new(hop_size),
                        n_mels: EditableOnText::new(n_mels),
                        sample_rate: EditableOnText::new(sample_rate),
                        layer,
                        result: None,
                    }
                }
                pub fn calc(&mut self, data: Array1<Complex<f64>>) -> crate::Result<()> {
                    self.result = self.layer.through_inner(&data)?;
                    Ok(())
                }
                pub fn update(&mut self) {
                    self.layer = ToMelSpectrogramLayer::new(
                        MelConfig::new(
                            self.fft_size.get(),
                            self.hop_size.get(),
                            self.n_mels.get(),
                            self.sample_rate.get(),
                        ),
                    );
                }
                pub fn get_result(&self) -> Option<Array2<f64>> {
                    self.result.clone()
                }
                pub const fn input() -> usize {
                    1 + 4
                }
                pub fn to_info(&self) -> MelLayerNodeInfo {
                    MelLayerNodeInfo
                }
            }
            pub struct SpectrogramDensityLayerNode {
                pub sample_rate: EditableOnText<f64>,
                pub time_range: EditableOnText<usize>,
                pub n_mels: EditableOnText<usize>,
                #[serde(skip)]
                layer: ToPowerSpectralDensityLayer,
                #[serde(skip)]
                result: Option<Array1<(f64, f64)>>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SpectrogramDensityLayerNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "SpectrogramDensityLayerNode",
                        "sample_rate",
                        &self.sample_rate,
                        "time_range",
                        &self.time_range,
                        "n_mels",
                        &self.n_mels,
                        "layer",
                        &self.layer,
                        "result",
                        &&self.result,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SpectrogramDensityLayerNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "SpectrogramDensityLayerNode",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "sample_rate",
                            &self.sample_rate,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "time_range",
                            &self.time_range,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "n_mels",
                            &self.n_mels,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            pub struct SpectrogramDensityLayerNodeInfo;
            impl NodeInfo for SpectrogramDensityLayerNodeInfo {
                fn name(&self) -> &str {
                    "SpectrogramDensityLayer"
                }
                fn inputs(&self) -> usize {
                    SpectrogramDensityLayerNode::input()
                }
                fn outputs(&self) -> usize {
                    1
                }
                fn input_types(&self) -> Vec<NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            NodeInfoTypes::Number,
                            NodeInfoTypes::Number,
                            NodeInfoTypes::Number,
                            NodeInfoTypes::Array2F64,
                        ]),
                    )
                }
                fn output_types(&self) -> Vec<NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([NodeInfoTypes::Array1TupleF64F64]),
                    )
                }
                fn flow_node(&self) -> super::editor::FlowNodes {
                    super::editor::FlowNodes::LayerNodes(
                        LayerNodes::SpectrogramDensityLayer(Default::default()),
                    )
                }
            }
            impl<'a> serde::Deserialize<'a> for SpectrogramDensityLayerNode {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: de::Deserializer<'a>,
                {
                    struct SpectrogramDensityLayerNodeHelper {
                        sample_rate: f64,
                        time_range: usize,
                        n_mels: usize,
                    }
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications
                    )]
                    const _: () = {
                        #[allow(unused_extern_crates, clippy::useless_attribute)]
                        extern crate serde as _serde;
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de>
                        for SpectrogramDensityLayerNodeHelper {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "sample_rate" => _serde::__private::Ok(__Field::__field0),
                                            "time_range" => _serde::__private::Ok(__Field::__field1),
                                            "n_mels" => _serde::__private::Ok(__Field::__field2),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"sample_rate" => _serde::__private::Ok(__Field::__field0),
                                            b"time_range" => _serde::__private::Ok(__Field::__field1),
                                            b"n_mels" => _serde::__private::Ok(__Field::__field2),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<
                                        SpectrogramDensityLayerNodeHelper,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = SpectrogramDensityLayerNodeHelper;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct SpectrogramDensityLayerNodeHelper",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            f64,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct SpectrogramDensityLayerNodeHelper with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match _serde::de::SeqAccess::next_element::<
                                            usize,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct SpectrogramDensityLayerNodeHelper with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field2 = match _serde::de::SeqAccess::next_element::<
                                            usize,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        2usize,
                                                        &"struct SpectrogramDensityLayerNodeHelper with 3 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(SpectrogramDensityLayerNodeHelper {
                                            sample_rate: __field0,
                                            time_range: __field1,
                                            n_mels: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<f64> = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<usize> = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<usize> = _serde::__private::None;
                                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                            __Field,
                                        >(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "sample_rate",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "time_range",
                                                            ),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("n_mels"),
                                                        );
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("sample_rate")?
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("time_range")?
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("n_mels")?
                                            }
                                        };
                                        _serde::__private::Ok(SpectrogramDensityLayerNodeHelper {
                                            sample_rate: __field0,
                                            time_range: __field1,
                                            n_mels: __field2,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &[
                                    "sample_rate",
                                    "time_range",
                                    "n_mels",
                                ];
                                _serde::Deserializer::deserialize_struct(
                                    __deserializer,
                                    "SpectrogramDensityLayerNodeHelper",
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<
                                            SpectrogramDensityLayerNodeHelper,
                                        >,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    let helper = SpectrogramDensityLayerNodeHelper::deserialize(
                        deserializer,
                    )?;
                    Ok(
                        SpectrogramDensityLayerNode::new(
                            helper.sample_rate,
                            helper.time_range,
                            helper.n_mels,
                        ),
                    )
                }
            }
            impl Default for SpectrogramDensityLayerNode {
                fn default() -> Self {
                    Self::new(44100.0, 20, 128)
                }
            }
            impl InputAndOutputType for SpectrogramDensityLayerNode {
                type Input = Array2<f64>;
                type Output = Array1<(f64, f64)>;
            }
            impl SpectrogramDensityLayerNode {
                pub fn new(sample_rate: f64, time_range: usize, n_mels: usize) -> Self {
                    let layer = ToPowerSpectralDensityLayer::new(ToPowerSpectralDensityLayerConfig {
                        sample_rate: sample_rate.into(),
                        time_range: time_range,
                        n_mels: n_mels,
                    });
                    Self {
                        sample_rate: EditableOnText::new(sample_rate),
                        time_range: EditableOnText::new(time_range),
                        n_mels: EditableOnText::new(n_mels),
                        layer,
                        result: None,
                    }
                }
                pub fn calc(&mut self, data: Array2<f64>) -> crate::Result<()> {
                    self.result = self.layer.through_inner(&data)?;
                    Ok(())
                }
                pub fn update(&mut self) {
                    self.layer = ToPowerSpectralDensityLayer::new(ToPowerSpectralDensityLayerConfig {
                        sample_rate: self.sample_rate.get().into(),
                        time_range: self.time_range.get(),
                        n_mels: self.n_mels.get(),
                    });
                }
                pub fn get_result(&self) -> Option<Array1<(f64, f64)>> {
                    self.result.clone()
                }
                pub const fn input() -> usize {
                    1 + 3
                }
                pub fn to_info(&self) -> SpectrogramDensityLayerNodeInfo {
                    SpectrogramDensityLayerNodeInfo
                }
            }
        }
        pub mod pin_info {
            use egui::{epaint::PathShape, Pos2, Shape, Vec2};
            use egui_snarl::ui::PinInfo;
            pub struct CustomPinInfo;
            impl CustomPinInfo {
                pub fn lock() -> PinInfo {
                    PinInfo::custom(move |painter, rect, color32, stroke| {
                        let key_width = rect.width();
                        let key_height = rect.height() * 0.7;
                        painter
                            .circle_stroke(
                                Pos2::new(
                                    rect.center().x,
                                    rect.center().y - rect.height() / 4.,
                                ),
                                rect.height() / 3.,
                                stroke,
                            );
                        painter
                            .rect(
                                egui::Rect::from_center_size(
                                    Pos2::new(
                                        rect.center().x,
                                        rect.center().y + rect.height() / 4.,
                                    ),
                                    Vec2::new(key_width, key_height),
                                ),
                                0.0,
                                color32,
                                stroke,
                            );
                    })
                }
                pub fn setting(teeth: usize) -> PinInfo {
                    PinInfo::custom(move |painter, rect, color32, stroke| {
                        let inner_radius = rect.size().min_elem() * 0.6;
                        let outer_radius = rect.size().min_elem() * 0.8;
                        let center = rect.center();
                        let mut pointers = Vec::with_capacity(teeth * 3);
                        for i in 0..8 {
                            let inner_angle = (i as f32 - 0.3) * std::f32::consts::PI
                                * 2.0 / teeth as f32;
                            let inner_x = inner_radius * inner_angle.cos();
                            let inner_y = inner_radius * inner_angle.sin();
                            let inner_point = Pos2::new(
                                center.x + inner_x,
                                center.y + inner_y,
                            );
                            let angle = (i as f32 - 0.1)
                                * (std::f32::consts::PI * 2.0 / teeth as f32);
                            let x = outer_radius * angle.cos();
                            let y = outer_radius * angle.sin();
                            let outer_point = Pos2::new(center.x + x, center.y + y);
                            let angle = (i as f32 + 0.1)
                                * (std::f32::consts::PI * 2.0 / teeth as f32);
                            let x = outer_radius * angle.cos();
                            let y = outer_radius * angle.sin();
                            let outer_point2 = Pos2::new(center.x + x, center.y + y);
                            let angle = (i as f32 + 0.3)
                                * (std::f32::consts::PI * 2.0 / teeth as f32);
                            let x = inner_radius * angle.cos();
                            let y = inner_radius * angle.sin();
                            let inner_point2 = Pos2::new(center.x + x, center.y + y);
                            pointers.push(inner_point);
                            pointers.push(outer_point);
                            pointers.push(outer_point2);
                            pointers.push(inner_point2);
                        }
                        let mut shape = PathShape::closed_line(pointers, stroke);
                        shape.fill = color32;
                        painter.add(Shape::Path(shape));
                    })
                }
            }
        }
        pub mod raw_input {
            #[cfg(not(target_family = "wasm"))]
            use audio_analyzer_core::data::device_stream::Device;
            use audio_analyzer_core::data::{test_data::TestData, RawDataStreamLayer};
            use egui_editable_num::EditableOnText;
            use super::NodeInfo;
            pub enum RawInputNodes {
                MicrophoneInputNode(MicrophoneInputNode),
                FileInputNode(FileInputNode),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for RawInputNodes {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        RawInputNodes::MicrophoneInputNode(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "MicrophoneInputNode",
                                &__self_0,
                            )
                        }
                        RawInputNodes::FileInputNode(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FileInputNode",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for RawInputNodes {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            RawInputNodes::MicrophoneInputNode(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "RawInputNodes",
                                    0u32,
                                    "MicrophoneInputNode",
                                    __field0,
                                )
                            }
                            RawInputNodes::FileInputNode(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "RawInputNodes",
                                    1u32,
                                    "FileInputNode",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RawInputNodes {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "MicrophoneInputNode" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    "FileInputNode" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"MicrophoneInputNode" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    b"FileInputNode" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RawInputNodes>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RawInputNodes;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum RawInputNodes",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                MicrophoneInputNode,
                                            >(__variant),
                                            RawInputNodes::MicrophoneInputNode,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                FileInputNode,
                                            >(__variant),
                                            RawInputNodes::FileInputNode,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "MicrophoneInputNode",
                            "FileInputNode",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "RawInputNodes",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<RawInputNodes>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            impl RawInputNodes {
                pub fn name(&self) -> &str {
                    match self {
                        RawInputNodes::MicrophoneInputNode(_) => "MicrophoneInputNode",
                        RawInputNodes::FileInputNode(_) => "FileInputNode",
                    }
                }
                pub fn get_sample_rate(&mut self) -> u32 {
                    match self {
                        RawInputNodes::MicrophoneInputNode(node) => {
                            node.get_sample_rate()
                        }
                        RawInputNodes::FileInputNode(node) => node.get_sample_rate(),
                    }
                }
                pub const fn inputs(&self) -> usize {
                    match self {
                        RawInputNodes::MicrophoneInputNode(node) => node.inputs(),
                        RawInputNodes::FileInputNode(node) => node.inputs(),
                    }
                }
                pub const fn outputs(&self) -> usize {
                    1
                }
                pub fn update(&mut self) {
                    match self {
                        RawInputNodes::MicrophoneInputNode(node) => node.update(),
                        RawInputNodes::FileInputNode(node) => node.update(),
                    }
                }
                pub fn get(&self) -> Option<Vec<f32>> {
                    match self {
                        RawInputNodes::MicrophoneInputNode(node) => {
                            match node {
                                #[cfg(not(target_family = "wasm"))]
                                MicrophoneInputNode::Device(_, vec) => vec.clone(),
                            }
                        }
                        RawInputNodes::FileInputNode(node) => node.vec.clone(),
                    }
                }
            }
            pub enum MicrophoneInputNode {
                #[cfg(not(target_family = "wasm"))]
                Device(Device, Option<Vec<f32>>),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MicrophoneInputNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        MicrophoneInputNode::Device(__self_0, __self_1) => {
                            ::core::fmt::Formatter::debug_tuple_field2_finish(
                                f,
                                "Device",
                                __self_0,
                                &__self_1,
                            )
                        }
                    }
                }
            }
            pub struct MicrophoneInputNodeInfo;
            impl NodeInfo for MicrophoneInputNodeInfo {
                fn name(&self) -> &str {
                    "MicrophoneInputNode"
                }
                fn inputs(&self) -> usize {
                    0
                }
                fn outputs(&self) -> usize {
                    1
                }
                fn input_types(&self) -> Vec<super::NodeInfoTypes> {
                    ::alloc::vec::Vec::new()
                }
                fn output_types(&self) -> Vec<super::NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([super::NodeInfoTypes::VecF32]),
                    )
                }
                fn flow_node(&self) -> super::editor::FlowNodes {
                    super::editor::FlowNodes::RawInputNodes(
                        RawInputNodes::MicrophoneInputNode(
                            MicrophoneInputNode::default(),
                        ),
                    )
                }
            }
            impl Default for MicrophoneInputNode {
                fn default() -> Self {
                    #[cfg(not(target_family = "wasm"))]
                    { MicrophoneInputNode::Device(Device::new(), None) }
                }
            }
            impl<'a> serde::Deserialize<'a> for MicrophoneInputNode {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'a>,
                {
                    enum Variant {
                        Device,
                        WebAudioStream,
                    }
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications
                    )]
                    const _: () = {
                        #[allow(unused_extern_crates, clippy::useless_attribute)]
                        extern crate serde as _serde;
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for Variant {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "variant identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"variant index 0 <= i < 2",
                                                    ),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "Device" => _serde::__private::Ok(__Field::__field0),
                                            "WebAudioStream" => _serde::__private::Ok(__Field::__field1),
                                            _ => {
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                                )
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"Device" => _serde::__private::Ok(__Field::__field0),
                                            b"WebAudioStream" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => {
                                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                                _serde::__private::Err(
                                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                                )
                                            }
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<Variant>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = Variant;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "enum Variant",
                                        )
                                    }
                                    fn visit_enum<__A>(
                                        self,
                                        __data: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::EnumAccess<'de>,
                                    {
                                        match _serde::de::EnumAccess::variant(__data)? {
                                            (__Field::__field0, __variant) => {
                                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                                _serde::__private::Ok(Variant::Device)
                                            }
                                            (__Field::__field1, __variant) => {
                                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                                _serde::__private::Ok(Variant::WebAudioStream)
                                            }
                                        }
                                    }
                                }
                                #[doc(hidden)]
                                const VARIANTS: &'static [&'static str] = &[
                                    "Device",
                                    "WebAudioStream",
                                ];
                                _serde::Deserializer::deserialize_enum(
                                    __deserializer,
                                    "Variant",
                                    VARIANTS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Variant>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    let variant = Variant::deserialize(deserializer)?;
                    match variant {
                        #[cfg(not(target_family = "wasm"))]
                        Variant::Device => Ok(MicrophoneInputNode::Device(Device::new())),
                        _ => {
                            Ok(MicrophoneInputNode::Device(Device::new()))
                        }
                    }
                }
            }
            impl<'a> serde::Serialize for MicrophoneInputNode {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    #[allow(dead_code)]
                    enum Variant {
                        Device,
                        WebAudioStream,
                    }
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications
                    )]
                    const _: () = {
                        #[allow(unused_extern_crates, clippy::useless_attribute)]
                        extern crate serde as _serde;
                        #[automatically_derived]
                        impl _serde::Serialize for Variant {
                            fn serialize<__S>(
                                &self,
                                __serializer: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                match *self {
                                    Variant::Device => {
                                        _serde::Serializer::serialize_unit_variant(
                                            __serializer,
                                            "Variant",
                                            0u32,
                                            "Device",
                                        )
                                    }
                                    Variant::WebAudioStream => {
                                        _serde::Serializer::serialize_unit_variant(
                                            __serializer,
                                            "Variant",
                                            1u32,
                                            "WebAudioStream",
                                        )
                                    }
                                }
                            }
                        }
                    };
                    let variant = match self {
                        #[cfg(not(target_family = "wasm"))]
                        MicrophoneInputNode::Device(_) => Variant::Device,
                    };
                    variant.serialize(serializer)
                }
            }
            impl MicrophoneInputNode {
                pub fn get_sample_rate(&mut self) -> u32 {
                    match self {
                        #[cfg(not(target_family = "wasm"))]
                        MicrophoneInputNode::Device(node, _) => {
                            node.get_sample_rate().expect("please start stream")
                        }
                    }
                }
                pub fn start(&mut self) {
                    match self {
                        #[cfg(not(target_family = "wasm"))]
                        MicrophoneInputNode::Device(node, _) => node.start(),
                    }
                }
                pub const fn inputs(&self) -> usize {
                    0
                }
                pub const fn outputs(&self) -> usize {
                    1
                }
                pub fn update(&mut self) {
                    match self {
                        #[cfg(not(target_family = "wasm"))]
                        MicrophoneInputNode::Device(node, vec) => *vec = node.try_recv(),
                    }
                }
                pub fn to_info(&self) -> MicrophoneInputNodeInfo {
                    MicrophoneInputNodeInfo
                }
            }
            pub struct FileInputNode {
                pub file_path: EditableOnText<String>,
                vec: Option<Vec<f32>>,
                #[serde(skip)]
                data: TestData,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for FileInputNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "FileInputNode",
                        "file_path",
                        &self.file_path,
                        "vec",
                        &self.vec,
                        "data",
                        &&self.data,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for FileInputNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "FileInputNode",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "file_path",
                            &self.file_path,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "vec",
                            &self.vec,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            pub struct FileInputNodeInfo;
            impl NodeInfo for FileInputNodeInfo {
                fn name(&self) -> &str {
                    "FileInputNode"
                }
                fn inputs(&self) -> usize {
                    1
                }
                fn outputs(&self) -> usize {
                    1
                }
                fn input_types(&self) -> Vec<super::NodeInfoTypes> {
                    ::alloc::vec::Vec::new()
                }
                fn output_types(&self) -> Vec<super::NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([super::NodeInfoTypes::VecF32]),
                    )
                }
                fn flow_node(&self) -> super::editor::FlowNodes {
                    super::editor::FlowNodes::RawInputNodes(
                        RawInputNodes::FileInputNode(FileInputNode::default()),
                    )
                }
            }
            impl Default for FileInputNode {
                fn default() -> Self {
                    Self::new("jfk_f32le.wav".to_string())
                }
            }
            impl<'a> serde::Deserialize<'a> for FileInputNode {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'a>,
                {
                    struct FileInputNodeHelper {
                        file_path: EditableOnText<String>,
                    }
                    #[doc(hidden)]
                    #[allow(
                        non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications
                    )]
                    const _: () = {
                        #[allow(unused_extern_crates, clippy::useless_attribute)]
                        extern crate serde as _serde;
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for FileInputNodeHelper {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "file_path" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"file_path" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<FileInputNodeHelper>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = FileInputNodeHelper;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct FileInputNodeHelper",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            EditableOnText<String>,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct FileInputNodeHelper with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(FileInputNodeHelper {
                                            file_path: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            EditableOnText<String>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                            __Field,
                                        >(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "file_path",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<
                                                            EditableOnText<String>,
                                                        >(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("file_path")?
                                            }
                                        };
                                        _serde::__private::Ok(FileInputNodeHelper {
                                            file_path: __field0,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &["file_path"];
                                _serde::Deserializer::deserialize_struct(
                                    __deserializer,
                                    "FileInputNodeHelper",
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<
                                            FileInputNodeHelper,
                                        >,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    };
                    let helper = FileInputNodeHelper::deserialize(deserializer)?;
                    Ok(FileInputNode::new(helper.file_path.as_ref().clone()))
                }
            }
            impl FileInputNode {
                pub fn new(file_path: String) -> Self {
                    Self {
                        file_path: EditableOnText::new(file_path.clone()),
                        data: TestData::new_with_path(file_path),
                        vec: None,
                    }
                }
                pub fn get_sample_rate(&mut self) -> u32 {
                    self.data.sample_rate()
                }
                pub fn start(&mut self) {
                    self.data.start();
                }
                pub const fn inputs(&self) -> usize {
                    1
                }
                pub const fn outputs(&self) -> usize {
                    1
                }
                pub fn update(&mut self) {
                    self.vec = self.data.try_recv();
                }
                pub fn to_info(&self) -> FileInputNodeInfo {
                    FileInputNodeInfo
                }
            }
        }
        pub mod utils {
            use super::{
                config::ConfigNodes, editor::FlowNodes, layer::LayerNodes,
                NodeInfoTypesWithData,
            };
            impl FlowNodes {
                pub fn to_node_info_types_with_data(
                    &self,
                ) -> Option<NodeInfoTypesWithData> {
                    match self {
                        FlowNodes::LayerNodes(layer_nodes) => {
                            match layer_nodes {
                                LayerNodes::STFTLayer(stft_layer_node) => {
                                    Some(
                                        NodeInfoTypesWithData::Array1ComplexF64(
                                            stft_layer_node.get_result()?,
                                        ),
                                    )
                                }
                                LayerNodes::MelLayer(mel_layer_node) => {
                                    Some(
                                        NodeInfoTypesWithData::Array2F64(
                                            mel_layer_node.get_result()?,
                                        ),
                                    )
                                }
                                LayerNodes::SpectrogramDensityLayer(
                                    spectrogram_density_layer_node,
                                ) => {
                                    Some(
                                        NodeInfoTypesWithData::Array1TupleF64F64(
                                            spectrogram_density_layer_node.get_result()?,
                                        ),
                                    )
                                }
                            }
                        }
                        FlowNodes::ConfigNodes(config_nodes) => {
                            match config_nodes {
                                ConfigNodes::NumberNode(number_node) => {
                                    Some(
                                        NodeInfoTypesWithData::Number(number_node.number.get()),
                                    )
                                }
                            }
                        }
                        FlowNodes::DataPlotterNode(_) => None,
                        FlowNodes::RawInputNodes(raw_input_nodes) => {
                            Some(NodeInfoTypesWithData::VecF32(raw_input_nodes.get()?))
                        }
                    }
                }
            }
        }
        pub mod viewer {
            use egui::{Pos2, Rect, Separator, UiBuilder, Vec2, Widget as _};
            use egui_editable_num::EditableOnText;
            use egui_plotter::EguiBackend;
            use ndarray::Array1;
            use super::NodeInfoTypesWithData;
            pub struct DataPlotterNode {
                pub name: String,
                pub hold_data: Option<NodeInfoTypesWithData>,
                pub size: EditableOnText<usize>,
                chart_pitch: f32,
                chart_yaw: f32,
                chart_scale: f32,
                chart_pitch_vel: f32,
                chart_yaw_vel: f32,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for DataPlotterNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "name",
                        "hold_data",
                        "size",
                        "chart_pitch",
                        "chart_yaw",
                        "chart_scale",
                        "chart_pitch_vel",
                        "chart_yaw_vel",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.name,
                        &self.hold_data,
                        &self.size,
                        &self.chart_pitch,
                        &self.chart_yaw,
                        &self.chart_scale,
                        &self.chart_pitch_vel,
                        &&self.chart_yaw_vel,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "DataPlotterNode",
                        names,
                        values,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for DataPlotterNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "DataPlotterNode",
                            false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "hold_data",
                            &self.hold_data,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "size",
                            &self.size,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chart_pitch",
                            &self.chart_pitch,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chart_yaw",
                            &self.chart_yaw,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chart_scale",
                            &self.chart_scale,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chart_pitch_vel",
                            &self.chart_pitch_vel,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chart_yaw_vel",
                            &self.chart_yaw_vel,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for DataPlotterNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "hold_data" => _serde::__private::Ok(__Field::__field1),
                                    "size" => _serde::__private::Ok(__Field::__field2),
                                    "chart_pitch" => _serde::__private::Ok(__Field::__field3),
                                    "chart_yaw" => _serde::__private::Ok(__Field::__field4),
                                    "chart_scale" => _serde::__private::Ok(__Field::__field5),
                                    "chart_pitch_vel" => {
                                        _serde::__private::Ok(__Field::__field6)
                                    }
                                    "chart_yaw_vel" => _serde::__private::Ok(__Field::__field7),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"hold_data" => _serde::__private::Ok(__Field::__field1),
                                    b"size" => _serde::__private::Ok(__Field::__field2),
                                    b"chart_pitch" => _serde::__private::Ok(__Field::__field3),
                                    b"chart_yaw" => _serde::__private::Ok(__Field::__field4),
                                    b"chart_scale" => _serde::__private::Ok(__Field::__field5),
                                    b"chart_pitch_vel" => {
                                        _serde::__private::Ok(__Field::__field6)
                                    }
                                    b"chart_yaw_vel" => _serde::__private::Ok(__Field::__field7),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<DataPlotterNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = DataPlotterNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct DataPlotterNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct DataPlotterNode with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Option<NodeInfoTypesWithData>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct DataPlotterNode with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    EditableOnText<usize>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct DataPlotterNode with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    f32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct DataPlotterNode with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    f32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct DataPlotterNode with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match _serde::de::SeqAccess::next_element::<
                                    f32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct DataPlotterNode with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field6 = match _serde::de::SeqAccess::next_element::<
                                    f32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                6usize,
                                                &"struct DataPlotterNode with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field7 = match _serde::de::SeqAccess::next_element::<
                                    f32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                7usize,
                                                &"struct DataPlotterNode with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(DataPlotterNode {
                                    name: __field0,
                                    hold_data: __field1,
                                    size: __field2,
                                    chart_pitch: __field3,
                                    chart_yaw: __field4,
                                    chart_scale: __field5,
                                    chart_pitch_vel: __field6,
                                    chart_yaw_vel: __field7,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Option<NodeInfoTypesWithData>,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    EditableOnText<usize>,
                                > = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<f32> = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<f32> = _serde::__private::None;
                                let mut __field5: _serde::__private::Option<f32> = _serde::__private::None;
                                let mut __field6: _serde::__private::Option<f32> = _serde::__private::None;
                                let mut __field7: _serde::__private::Option<f32> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "hold_data",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<NodeInfoTypesWithData>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    EditableOnText<usize>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "chart_pitch",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "chart_yaw",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "chart_scale",
                                                    ),
                                                );
                                            }
                                            __field5 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field6 => {
                                            if _serde::__private::Option::is_some(&__field6) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "chart_pitch_vel",
                                                    ),
                                                );
                                            }
                                            __field6 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field7 => {
                                            if _serde::__private::Option::is_some(&__field7) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "chart_yaw_vel",
                                                    ),
                                                );
                                            }
                                            __field7 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<f32>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("hold_data")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("size")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("chart_pitch")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("chart_yaw")?
                                    }
                                };
                                let __field5 = match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("chart_scale")?
                                    }
                                };
                                let __field6 = match __field6 {
                                    _serde::__private::Some(__field6) => __field6,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("chart_pitch_vel")?
                                    }
                                };
                                let __field7 = match __field7 {
                                    _serde::__private::Some(__field7) => __field7,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("chart_yaw_vel")?
                                    }
                                };
                                _serde::__private::Ok(DataPlotterNode {
                                    name: __field0,
                                    hold_data: __field1,
                                    size: __field2,
                                    chart_pitch: __field3,
                                    chart_yaw: __field4,
                                    chart_scale: __field5,
                                    chart_pitch_vel: __field6,
                                    chart_yaw_vel: __field7,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "name",
                            "hold_data",
                            "size",
                            "chart_pitch",
                            "chart_yaw",
                            "chart_scale",
                            "chart_pitch_vel",
                            "chart_yaw_vel",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "DataPlotterNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<DataPlotterNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            use plotters::prelude::*;
            pub struct DataPlotterNodeInfo;
            impl super::NodeInfo for DataPlotterNodeInfo {
                fn name(&self) -> &str {
                    "DataPlotterNode"
                }
                fn inputs(&self) -> usize {
                    1
                }
                fn outputs(&self) -> usize {
                    0
                }
                fn input_types(&self) -> Vec<super::NodeInfoTypes> {
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([super::NodeInfoTypes::AnyInput]),
                    )
                }
                fn output_types(&self) -> Vec<super::NodeInfoTypes> {
                    ::alloc::vec::Vec::new()
                }
                fn flow_node(&self) -> super::editor::FlowNodes {
                    super::editor::FlowNodes::DataPlotterNode(DataPlotterNode::default())
                }
            }
            impl Default for DataPlotterNode {
                fn default() -> Self {
                    Self::new("DataPlotterNode".to_string())
                }
            }
            impl DataPlotterNode {
                pub fn new(name: String) -> Self {
                    Self {
                        name,
                        hold_data: None,
                        size: EditableOnText::new(100),
                        chart_pitch: 0.3,
                        chart_yaw: 0.9,
                        chart_scale: 0.9,
                        chart_pitch_vel: 0.0,
                        chart_yaw_vel: 0.0,
                    }
                }
                pub fn set_hold_data(&mut self, hold_data: NodeInfoTypesWithData) {
                    self.hold_data = Some(hold_data);
                }
                pub fn get_hold_data(&self) -> Option<&NodeInfoTypesWithData> {
                    self.hold_data.as_ref()
                }
                pub fn to_info(&self) -> DataPlotterNodeInfo {
                    DataPlotterNodeInfo
                }
                pub fn show(&mut self, ui: &mut egui::Ui, _is_new: bool, scale: f32) {
                    let hold_data = self.hold_data.clone();
                    if let Some(hold_data) = hold_data {
                        match hold_data {
                            NodeInfoTypesWithData::Number(number) => {
                                ui.label(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Number: {0}", number),
                                        );
                                        res
                                    }),
                                );
                            }
                            NodeInfoTypesWithData::VecF32(vec_f32) => {
                                self.show_vec_f32(ui, vec_f32, scale);
                            }
                            NodeInfoTypesWithData::Array1TupleF64F64(
                                array1_tuple_f64_f64,
                            ) => {
                                self.show_array1_tuple_f64_f64(
                                    ui,
                                    array1_tuple_f64_f64,
                                    scale,
                                );
                            }
                            NodeInfoTypesWithData::Array2F64(array2_f64) => {
                                ui.label(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Array2F64: {0:?}", array2_f64),
                                        );
                                        res
                                    }),
                                );
                            }
                            NodeInfoTypesWithData::Array1ComplexF64(
                                array1_complex_f64,
                            ) => {
                                self.show_array1_complex_f64(ui, array1_complex_f64, scale);
                            }
                        }
                    }
                }
                pub fn show_vec_f32(
                    &mut self,
                    ui: &mut egui::Ui,
                    vec_f32: Vec<f32>,
                    scale: f32,
                ) {
                    self.plot(
                        ui,
                        scale,
                        |ui, scale, _| {
                            let root = EguiBackend::new(&ui).into_drawing_area();
                            let mut chart = ChartBuilder::on(&root)
                                .caption(
                                    "vec<f32> stream",
                                    ("sans-serif", 5. * scale).into_font(),
                                )
                                .margin(10. * scale)
                                .x_label_area_size((3. * scale) as i32)
                                .y_label_area_size((3. * scale) as i32)
                                .build_cartesian_2d(0f32..1f32, -0.1f32..1f32)
                                .unwrap();
                            chart
                                .configure_mesh()
                                .label_style(("sans-serif", 5. * scale).into_font())
                                .draw()
                                .unwrap();
                            chart
                                .draw_series(
                                    LineSeries::new(
                                        vec_f32
                                            .iter()
                                            .enumerate()
                                            .map(|(x, y)| (x as f32 / vec_f32.len() as f32, *y)),
                                        &RED,
                                    ),
                                )
                                .unwrap()
                                .label("vec<f32> stream")
                                .legend(|(x, y)| {
                                    PathElement::new(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                (x, y),
                                                (x + (2. * scale) as i32, y),
                                            ]),
                                        ),
                                        &RED,
                                    )
                                });
                            root.present().unwrap();
                        },
                    );
                }
                pub fn show_array1_tuple_f64_f64(
                    &mut self,
                    ui: &mut egui::Ui,
                    array1_tuple_f64_f64: Array1<(f64, f64)>,
                    scale: f32,
                ) {
                    self.plot(
                        ui,
                        scale,
                        |ui, scale, _| {
                            let root = EguiBackend::new(&ui).into_drawing_area();
                            let mut chart = ChartBuilder::on(&root)
                                .caption(
                                    "Array1TupleF64F64 stream",
                                    ("sans-serif", 5. * scale).into_font(),
                                )
                                .margin(10. * scale)
                                .x_label_area_size((3. * scale) as i32)
                                .y_label_area_size((3. * scale) as i32)
                                .build_cartesian_2d(0f64..1f64, -0.1f64..1f64)
                                .unwrap();
                            chart
                                .configure_mesh()
                                .label_style(("sans-serif", 5. * scale).into_font())
                                .draw()
                                .unwrap();
                            chart
                                .draw_series(
                                    LineSeries::new(
                                        array1_tuple_f64_f64
                                            .iter()
                                            .enumerate()
                                            .map(|(x, y)| (
                                                x as f64 / array1_tuple_f64_f64.len() as f64,
                                                y.0,
                                            )),
                                        &RED,
                                    ),
                                )
                                .unwrap()
                                .label("Array1<(F64, F64)> stream")
                                .legend(|(x, y)| {
                                    PathElement::new(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                (x, y),
                                                (x + (2. * scale) as i32, y),
                                            ]),
                                        ),
                                        &RED,
                                    )
                                });
                            chart
                                .draw_series(
                                    LineSeries::new(
                                        array1_tuple_f64_f64
                                            .iter()
                                            .enumerate()
                                            .map(|(x, y)| (
                                                x as f64 / array1_tuple_f64_f64.len() as f64,
                                                y.1,
                                            )),
                                        &BLUE,
                                    ),
                                )
                                .unwrap()
                                .label("Array1<(F64, F64)> stream")
                                .legend(|(x, y)| {
                                    PathElement::new(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                (x, y),
                                                (x + (2. * scale) as i32, y),
                                            ]),
                                        ),
                                        &BLUE,
                                    )
                                });
                            chart
                                .configure_series_labels()
                                .legend_area_size((2. * scale) as i32)
                                .label_font(("sans-serif", 5. * scale))
                                .background_style(&WHITE.mix(0.8))
                                .border_style(&BLACK)
                                .draw()
                                .unwrap();
                            root.present().unwrap();
                        },
                    );
                }
                pub fn show_array1_complex_f64(
                    &mut self,
                    ui: &mut egui::Ui,
                    complex_array: Array1<num_complex::Complex<f64>>,
                    scale: f32,
                ) {
                    let points: Vec<_> = complex_array
                        .iter()
                        .enumerate()
                        .map(|(i, c)| {
                            let time = i as f64;
                            let frequency = (i % 5) as f64;
                            let amplitude = c.norm();
                            (time, frequency, amplitude)
                        })
                        .collect();
                    self.plot(
                        ui,
                        scale,
                        |ui, scale, sl| {
                            const MOVE_SCALE: f32 = 0.01;
                            const SCROLL_SCALE: f32 = 0.001;
                            if ui.rect_contains_pointer(ui.max_rect()) {
                                let (pitch_delta, yaw_delta, scale_delta) = ui
                                    .input(|input| {
                                        let pointer = &input.pointer;
                                        let delta = pointer.delta();
                                        let (pitch_delta, yaw_delta) = match pointer.primary_down()
                                        {
                                            true => (delta.y * MOVE_SCALE, -delta.x * MOVE_SCALE),
                                            false => (sl.chart_pitch_vel, sl.chart_yaw_vel),
                                        };
                                        let scale_delta = input.raw_scroll_delta.y * SCROLL_SCALE;
                                        (pitch_delta, yaw_delta, scale_delta)
                                    });
                                sl.chart_pitch_vel = pitch_delta;
                                sl.chart_yaw_vel = yaw_delta;
                                sl.chart_pitch += sl.chart_pitch_vel;
                                sl.chart_yaw += sl.chart_yaw_vel;
                                sl.chart_scale += scale_delta;
                            }
                            let root = EguiBackend::new(&ui).into_drawing_area();
                            let mut chart = ChartBuilder::on(&root)
                                .caption(
                                    "Array1<Complex<F64>> stream",
                                    ("sans-serif", 5. * scale).into_font(),
                                )
                                .margin(10. * scale)
                                .x_label_area_size((3. * scale) as i32)
                                .y_label_area_size((3. * scale) as i32)
                                .build_cartesian_3d(0f64..1000f64, 0f64..5f64, 0f64..1f64)
                                .unwrap();
                            chart
                                .with_projection(|mut pb| {
                                    pb.yaw = sl.chart_yaw as f64;
                                    pb.pitch = sl.chart_pitch as f64;
                                    pb.scale = sl.chart_scale as f64;
                                    pb.into_matrix()
                                });
                            chart
                                .configure_axes()
                                .light_grid_style(&WHITE.mix(0.8))
                                .max_light_lines(3)
                                .label_style(("sans-serif", 5. * scale).into_font())
                                .draw()
                                .unwrap();
                            chart
                                .draw_series(
                                    points
                                        .iter()
                                        .map(|(x, y, z)| Circle::new((*x, *y, *z), 2, &RED)),
                                )
                                .unwrap()
                                .label("Array1<Complex<F64>> stream")
                                .legend(|(x, y)| {
                                    Rectangle::new(
                                        [(x, y), (x + (2. * scale) as i32, y)],
                                        BLUE.mix(0.5).filled(),
                                    )
                                });
                            root.present().unwrap();
                        },
                    );
                }
                pub fn plot<F: FnMut(&mut egui::Ui, f32, &mut DataPlotterNode)>(
                    &mut self,
                    ui: &mut egui::Ui,
                    scale: f32,
                    mut f: F,
                ) {
                    ui.scope_builder(
                        UiBuilder::new()
                            .max_rect({
                                let mut rect = ui.available_rect_before_wrap();
                                rect.max.x = rect.min.x + 100.0 * scale;
                                rect.max.y = rect.min.y + 100.0 * scale;
                                rect
                            }),
                        |ui| {
                            ui.columns(
                                1,
                                |ui| {
                                    let ui = &mut ui[0];
                                    ui.label(self.name.clone());
                                    Separator::default().horizontal().ui(ui);
                                    ui.label("size: ");
                                    if egui::TextEdit::singleline(&mut self.size)
                                        .clip_text(false)
                                        .show(ui)
                                        .response
                                        .lost_focus()
                                    {
                                        self.size.fmt();
                                    }
                                    ui.separator();
                                },
                            );
                            ui.separator();
                        },
                    );
                    let scale = scale * self.size.get() as f32 / 100.0;
                    ui.set_min_size(Vec2::new(100.0 * scale, 100.0 * scale));
                    ui.scope_builder(
                        UiBuilder::new()
                            .max_rect({
                                let mut rect = ui.available_rect_before_wrap();
                                rect.max.x = rect.min.x + 100.0 * scale;
                                rect.max.y = rect.min.y + 100.0 * scale;
                                rect
                            }),
                        |new_ui| {
                            f(new_ui, scale, self);
                        },
                    );
                }
            }
        }
        pub trait NodeInfo {
            fn name(&self) -> &str;
            fn inputs(&self) -> usize;
            fn outputs(&self) -> usize;
            fn input_types(&self) -> Vec<NodeInfoTypes>;
            fn output_types(&self) -> Vec<NodeInfoTypes>;
            fn flow_node(&self) -> editor::FlowNodes;
        }
        pub enum NodeInfoTypes {
            Number,
            VecF32,
            Array1TupleF64F64,
            Array2F64,
            Array1ComplexF64,
            AnyInput,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NodeInfoTypes {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        NodeInfoTypes::Number => "Number",
                        NodeInfoTypes::VecF32 => "VecF32",
                        NodeInfoTypes::Array1TupleF64F64 => "Array1TupleF64F64",
                        NodeInfoTypes::Array2F64 => "Array2F64",
                        NodeInfoTypes::Array1ComplexF64 => "Array1ComplexF64",
                        NodeInfoTypes::AnyInput => "AnyInput",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NodeInfoTypes {
            #[inline]
            fn clone(&self) -> NodeInfoTypes {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NodeInfoTypes {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NodeInfoTypes {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NodeInfoTypes {
            #[inline]
            fn eq(&self, other: &NodeInfoTypes) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NodeInfoTypes {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl NodeInfoTypes {
            pub fn contains_out(&self, other: &[NodeInfoTypes]) -> bool {
                other.iter().any(|x| x == self || x == &NodeInfoTypes::AnyInput)
            }
            pub fn positions_out(&self, other: &[NodeInfoTypes]) -> Vec<usize> {
                other
                    .iter()
                    .enumerate()
                    .filter_map(|(i, x)| {
                        if x == self || x == &NodeInfoTypes::AnyInput {
                            Some(i)
                        } else {
                            None
                        }
                    })
                    .collect()
            }
            pub fn contains_in(&self, other: &[NodeInfoTypes]) -> bool {
                other.iter().any(|x| x == self)
                    || (self == &NodeInfoTypes::AnyInput && !other.is_empty())
            }
            pub fn positions_in(&self, other: &[NodeInfoTypes]) -> Vec<usize> {
                if self == &NodeInfoTypes::AnyInput {
                    other.iter().enumerate().map(|(i, _)| i).collect()
                } else {
                    other
                        .iter()
                        .enumerate()
                        .filter_map(|(i, x)| if x == self { Some(i) } else { None })
                        .collect()
                }
            }
        }
        pub enum NodeInfoTypesWithData {
            Number(f64),
            VecF32(Vec<f32>),
            Array1TupleF64F64(Array1<(f64, f64)>),
            Array2F64(Array2<f64>),
            Array1ComplexF64(Array1<num_complex::Complex<f64>>),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NodeInfoTypesWithData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    NodeInfoTypesWithData::Number(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Number",
                            &__self_0,
                        )
                    }
                    NodeInfoTypesWithData::VecF32(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "VecF32",
                            &__self_0,
                        )
                    }
                    NodeInfoTypesWithData::Array1TupleF64F64(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Array1TupleF64F64",
                            &__self_0,
                        )
                    }
                    NodeInfoTypesWithData::Array2F64(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Array2F64",
                            &__self_0,
                        )
                    }
                    NodeInfoTypesWithData::Array1ComplexF64(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Array1ComplexF64",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for NodeInfoTypesWithData {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        NodeInfoTypesWithData::Number(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "NodeInfoTypesWithData",
                                0u32,
                                "Number",
                                __field0,
                            )
                        }
                        NodeInfoTypesWithData::VecF32(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "NodeInfoTypesWithData",
                                1u32,
                                "VecF32",
                                __field0,
                            )
                        }
                        NodeInfoTypesWithData::Array1TupleF64F64(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "NodeInfoTypesWithData",
                                2u32,
                                "Array1TupleF64F64",
                                __field0,
                            )
                        }
                        NodeInfoTypesWithData::Array2F64(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "NodeInfoTypesWithData",
                                3u32,
                                "Array2F64",
                                __field0,
                            )
                        }
                        NodeInfoTypesWithData::Array1ComplexF64(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "NodeInfoTypesWithData",
                                4u32,
                                "Array1ComplexF64",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for NodeInfoTypesWithData {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 5",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Number" => _serde::__private::Ok(__Field::__field0),
                                "VecF32" => _serde::__private::Ok(__Field::__field1),
                                "Array1TupleF64F64" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "Array2F64" => _serde::__private::Ok(__Field::__field3),
                                "Array1ComplexF64" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Number" => _serde::__private::Ok(__Field::__field0),
                                b"VecF32" => _serde::__private::Ok(__Field::__field1),
                                b"Array1TupleF64F64" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"Array2F64" => _serde::__private::Ok(__Field::__field3),
                                b"Array1ComplexF64" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<NodeInfoTypesWithData>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = NodeInfoTypesWithData;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum NodeInfoTypesWithData",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            f64,
                                        >(__variant),
                                        NodeInfoTypesWithData::Number,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Vec<f32>,
                                        >(__variant),
                                        NodeInfoTypesWithData::VecF32,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Array1<(f64, f64)>,
                                        >(__variant),
                                        NodeInfoTypesWithData::Array1TupleF64F64,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Array2<f64>,
                                        >(__variant),
                                        NodeInfoTypesWithData::Array2F64,
                                    )
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Array1<num_complex::Complex<f64>>,
                                        >(__variant),
                                        NodeInfoTypesWithData::Array1ComplexF64,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "Number",
                        "VecF32",
                        "Array1TupleF64F64",
                        "Array2F64",
                        "Array1ComplexF64",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "NodeInfoTypesWithData",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                NodeInfoTypesWithData,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for NodeInfoTypesWithData {
            #[inline]
            fn clone(&self) -> NodeInfoTypesWithData {
                match self {
                    NodeInfoTypesWithData::Number(__self_0) => {
                        NodeInfoTypesWithData::Number(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    NodeInfoTypesWithData::VecF32(__self_0) => {
                        NodeInfoTypesWithData::VecF32(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    NodeInfoTypesWithData::Array1TupleF64F64(__self_0) => {
                        NodeInfoTypesWithData::Array1TupleF64F64(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    NodeInfoTypesWithData::Array2F64(__self_0) => {
                        NodeInfoTypesWithData::Array2F64(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    NodeInfoTypesWithData::Array1ComplexF64(__self_0) => {
                        NodeInfoTypesWithData::Array1ComplexF64(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        pub struct NodeInfos;
        impl NodeInfos {
            pub fn all() -> Vec<Box<dyn NodeInfo>> {
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        Box::new(NumberNodeInfo),
                        Box::new(STFTLayerNodeInfo),
                        Box::new(MelLayerNodeInfo),
                        Box::new(SpectrogramDensityLayerNodeInfo),
                        Box::new(MicrophoneInputNodeInfo),
                        Box::new(FileInputNodeInfo),
                        Box::new(DataPlotterNodeInfo),
                        Box::new(ExprNodeInfo::default()),
                    ]),
                )
            }
        }
        pub trait SerdeClone: serde::Serialize + serde::de::DeserializeOwned {
            fn serde_clone(&self) -> Self {
                serde_json::from_str(&serde_json::to_string(self).unwrap()).unwrap()
            }
        }
        impl<T> SerdeClone for T
        where
            T: serde::Serialize + serde::de::DeserializeOwned,
        {}
    }
    pub mod separate_window_widget {
        use std::sync::{atomic::AtomicBool, Arc};
        use egui::mutex::Mutex;
        use super::widget::{UiWidget, View};
        pub struct SeparateWindowWidget<W: UiWidget + View> {
            title: String,
            initial_size: [f32; 2],
            show: Arc<AtomicBool>,
            widget: Arc<Mutex<W>>,
        }
        impl<W: UiWidget + View + Send + 'static> SeparateWindowWidget<W> {
            pub fn new(initial_size: [f32; 2], widget: W) -> Self {
                SeparateWindowWidget {
                    title: widget.name().to_string(),
                    initial_size,
                    show: Arc::new(AtomicBool::new(true)),
                    widget: Arc::new(Mutex::new(widget)),
                }
            }
            #[cfg(not(target_arch = "wasm32"))]
            pub fn show(&mut self, ctx: &egui::Context) {
                if self.show.load(std::sync::atomic::Ordering::Relaxed) {
                    let widget = Arc::clone(&self.widget);
                    let show = Arc::clone(&self.show);
                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of(&self.title),
                        egui::ViewportBuilder::default()
                            .with_title(&self.title)
                            .with_inner_size(self.initial_size),
                        move |ctx, _class| {
                            let widget = widget.clone();
                            egui::CentralPanel::default()
                                .show(
                                    ctx,
                                    |ui| {
                                        let mut widget = widget.lock();
                                        widget.ui(ui);
                                    },
                                );
                            if ctx.input(|i| i.viewport().close_requested()) {
                                show.store(false, std::sync::atomic::Ordering::Relaxed);
                            }
                        },
                    );
                }
            }
        }
    }
    pub mod stream {
        use audio_analyzer_core::{
            data::RawDataStreamLayer as _, layer::layers::MultipleLayers,
            mel_layer::{
                fft_layer::{FftConfig, ToSpectrogramLayer},
                spectral_density::{
                    ToPowerSpectralDensityLayer, ToPowerSpectralDensityLayerConfig,
                },
                to_mel_layer::ToMelSpectrogramLayer,
            },
        };
        use log::debug;
        use mel_spec::config::MelConfig;
        use streams::Streamer;
        pub mod streams {
            use audio_analyzer_core::{
                data::RawDataStreamLayer, layer::{layers::MultipleLayers, Layer as _},
            };
            use log::debug;
            use ndarray::{Array1, Axis as npAxis};
            use std::fmt::Debug;
            use std::{any::Any, thread, time::{Duration, Instant}};
            use crate::Result;
            pub struct Streamer {
                input_stream: Box<dyn RawDataStreamLayer>,
                layer: MultipleLayers,
                mel_psd_data: Vec<(f64, f64)>,
            }
            impl Streamer {
                pub fn new(
                    input_stream: Box<dyn RawDataStreamLayer>,
                    layer: MultipleLayers,
                ) -> Self {
                    Self {
                        input_stream,
                        layer,
                        mel_psd_data: ::alloc::vec::Vec::new(),
                    }
                }
                pub fn apply(&mut self) {
                    if let Some(data) = self.input_stream.try_recv() {
                        if let Ok(mel_data) = self.layer.through(&data as &dyn Any) {
                            if mel_data.len() != 0 {}
                            if let Some(mel_data) = mel_data
                                .iter()
                                .last()
                                .map(|x| x.downcast_ref::<Array1<(f64, f64)>>().unwrap())
                                .clone()
                            {
                                self.mel_psd_data = mel_data.to_vec();
                            }
                        }
                    }
                }
            }
        }
        pub fn new_stream() -> Streamer {
            #[cfg(not(target_family = "wasm"))]
            let mut raw_data_layer = device_stream::Device::new();
            raw_data_layer.start();
            let sample_rate = raw_data_layer.sample_rate();
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("sample rate: {0}", sample_rate),
                        lvl,
                        &(
                            "audio_analyzer_app::libs::stream",
                            "audio_analyzer_app::libs::stream",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            let fft_layer = ToSpectrogramLayer::new(FftConfig::new(400, 160));
            let mel_layer = ToMelSpectrogramLayer::new(
                MelConfig::new(400, 160, 80, sample_rate.into()),
            );
            let psd_layer = ToPowerSpectralDensityLayer::new(ToPowerSpectralDensityLayerConfig {
                sample_rate: sample_rate.into(),
                time_range: 20,
                n_mels: 80,
            });
            let mut layers = MultipleLayers::default();
            layers.push_layer(fft_layer);
            layers.push_layer(mel_layer);
            layers.push_layer(psd_layer);
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("{0:?}", layers),
                        lvl,
                        &(
                            "audio_analyzer_app::libs::stream",
                            "audio_analyzer_app::libs::stream",
                            ::log::__private_api::loc(),
                        ),
                        (),
                    );
                }
            };
            Streamer::new(Box::new(raw_data_layer), layers)
        }
    }
    pub mod utils {
        pub mod log {
            use egui_tracing::EventCollector;
            use crate::libs::widget::{UiWidget, View};
            pub struct LogViewerWidget {
                collector: EventCollector,
            }
            impl View for LogViewerWidget {
                fn ui(&mut self, ui: &mut egui::Ui) {
                    ui.style_mut().wrap_mode = Some(egui::TextWrapMode::Truncate);
                    ui.add(egui_tracing::Logs::new(self.collector.clone()));
                }
            }
            impl UiWidget for LogViewerWidget {
                fn name<'a>(&'a self) -> &'a str {
                    "Log Viewer"
                }
            }
            impl LogViewerWidget {
                pub fn new(collector: EventCollector) -> Self {
                    Self { collector }
                }
            }
        }
    }
    pub mod widget {
        pub trait UiWidget {
            fn is_enabled(&self, _ctx: &egui::Context) -> bool {
                true
            }
            fn name<'a>(&'a self) -> &'a str;
        }
        pub trait View {
            fn ui(&mut self, ui: &mut egui::Ui);
        }
    }
}
